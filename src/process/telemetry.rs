// This file is generated by rust-protobuf 2.10.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `telemetry.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_10_1;

#[derive(PartialEq,Clone,Default)]
pub struct Overview {
    // message fields
    pub time: f64,
    pub pos: ::protobuf::SingularPtrField<Position>,
    pub rot: ::protobuf::SingularPtrField<Rotation>,
    pub alt: ::protobuf::SingularPtrField<Altitude>,
    pub vel: ::protobuf::SingularPtrField<Velocity>,
    pub speed: ::protobuf::SingularPtrField<Speed>,
    pub battery: ::protobuf::SingularPtrField<Battery>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Overview {
    fn default() -> &'a Overview {
        <Overview as ::protobuf::Message>::default_instance()
    }
}

impl Overview {
    pub fn new() -> Overview {
        ::std::default::Default::default()
    }

    // double time = 1;


    pub fn get_time(&self) -> f64 {
        self.time
    }
    pub fn clear_time(&mut self) {
        self.time = 0.;
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: f64) {
        self.time = v;
    }

    // .telemetry.Position pos = 2;


    pub fn get_pos(&self) -> &Position {
        self.pos.as_ref().unwrap_or_else(|| Position::default_instance())
    }
    pub fn clear_pos(&mut self) {
        self.pos.clear();
    }

    pub fn has_pos(&self) -> bool {
        self.pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos(&mut self, v: Position) {
        self.pos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pos(&mut self) -> &mut Position {
        if self.pos.is_none() {
            self.pos.set_default();
        }
        self.pos.as_mut().unwrap()
    }

    // Take field
    pub fn take_pos(&mut self) -> Position {
        self.pos.take().unwrap_or_else(|| Position::new())
    }

    // .telemetry.Rotation rot = 3;


    pub fn get_rot(&self) -> &Rotation {
        self.rot.as_ref().unwrap_or_else(|| Rotation::default_instance())
    }
    pub fn clear_rot(&mut self) {
        self.rot.clear();
    }

    pub fn has_rot(&self) -> bool {
        self.rot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rot(&mut self, v: Rotation) {
        self.rot = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rot(&mut self) -> &mut Rotation {
        if self.rot.is_none() {
            self.rot.set_default();
        }
        self.rot.as_mut().unwrap()
    }

    // Take field
    pub fn take_rot(&mut self) -> Rotation {
        self.rot.take().unwrap_or_else(|| Rotation::new())
    }

    // .telemetry.Altitude alt = 4;


    pub fn get_alt(&self) -> &Altitude {
        self.alt.as_ref().unwrap_or_else(|| Altitude::default_instance())
    }
    pub fn clear_alt(&mut self) {
        self.alt.clear();
    }

    pub fn has_alt(&self) -> bool {
        self.alt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_alt(&mut self, v: Altitude) {
        self.alt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_alt(&mut self) -> &mut Altitude {
        if self.alt.is_none() {
            self.alt.set_default();
        }
        self.alt.as_mut().unwrap()
    }

    // Take field
    pub fn take_alt(&mut self) -> Altitude {
        self.alt.take().unwrap_or_else(|| Altitude::new())
    }

    // .telemetry.Velocity vel = 5;


    pub fn get_vel(&self) -> &Velocity {
        self.vel.as_ref().unwrap_or_else(|| Velocity::default_instance())
    }
    pub fn clear_vel(&mut self) {
        self.vel.clear();
    }

    pub fn has_vel(&self) -> bool {
        self.vel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vel(&mut self, v: Velocity) {
        self.vel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vel(&mut self) -> &mut Velocity {
        if self.vel.is_none() {
            self.vel.set_default();
        }
        self.vel.as_mut().unwrap()
    }

    // Take field
    pub fn take_vel(&mut self) -> Velocity {
        self.vel.take().unwrap_or_else(|| Velocity::new())
    }

    // .telemetry.Speed speed = 6;


    pub fn get_speed(&self) -> &Speed {
        self.speed.as_ref().unwrap_or_else(|| Speed::default_instance())
    }
    pub fn clear_speed(&mut self) {
        self.speed.clear();
    }

    pub fn has_speed(&self) -> bool {
        self.speed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_speed(&mut self, v: Speed) {
        self.speed = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_speed(&mut self) -> &mut Speed {
        if self.speed.is_none() {
            self.speed.set_default();
        }
        self.speed.as_mut().unwrap()
    }

    // Take field
    pub fn take_speed(&mut self) -> Speed {
        self.speed.take().unwrap_or_else(|| Speed::new())
    }

    // .telemetry.Battery battery = 7;


    pub fn get_battery(&self) -> &Battery {
        self.battery.as_ref().unwrap_or_else(|| Battery::default_instance())
    }
    pub fn clear_battery(&mut self) {
        self.battery.clear();
    }

    pub fn has_battery(&self) -> bool {
        self.battery.is_some()
    }

    // Param is passed by value, moved
    pub fn set_battery(&mut self, v: Battery) {
        self.battery = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_battery(&mut self) -> &mut Battery {
        if self.battery.is_none() {
            self.battery.set_default();
        }
        self.battery.as_mut().unwrap()
    }

    // Take field
    pub fn take_battery(&mut self) -> Battery {
        self.battery.take().unwrap_or_else(|| Battery::new())
    }
}

impl ::protobuf::Message for Overview {
    fn is_initialized(&self) -> bool {
        for v in &self.pos {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rot {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.alt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vel {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.speed {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.battery {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.time = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pos)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rot)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.alt)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.vel)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.speed)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.battery)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.time != 0. {
            my_size += 9;
        }
        if let Some(ref v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rot.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.alt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.vel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.speed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.battery.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.time != 0. {
            os.write_double(1, self.time)?;
        }
        if let Some(ref v) = self.pos.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rot.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.alt.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.vel.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.speed.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.battery.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Overview {
        Overview::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "time",
                    |m: &Overview| { &m.time },
                    |m: &mut Overview| { &mut m.time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Position>>(
                    "pos",
                    |m: &Overview| { &m.pos },
                    |m: &mut Overview| { &mut m.pos },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Rotation>>(
                    "rot",
                    |m: &Overview| { &m.rot },
                    |m: &mut Overview| { &mut m.rot },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Altitude>>(
                    "alt",
                    |m: &Overview| { &m.alt },
                    |m: &mut Overview| { &mut m.alt },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Velocity>>(
                    "vel",
                    |m: &Overview| { &m.vel },
                    |m: &mut Overview| { &mut m.vel },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Speed>>(
                    "speed",
                    |m: &Overview| { &m.speed },
                    |m: &mut Overview| { &mut m.speed },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Battery>>(
                    "battery",
                    |m: &Overview| { &m.battery },
                    |m: &mut Overview| { &mut m.battery },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Overview>(
                    "Overview",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Overview {
        static mut instance: ::protobuf::lazy::Lazy<Overview> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Overview,
        };
        unsafe {
            instance.get(Overview::new)
        }
    }
}

impl ::protobuf::Clear for Overview {
    fn clear(&mut self) {
        self.time = 0.;
        self.pos.clear();
        self.rot.clear();
        self.alt.clear();
        self.vel.clear();
        self.speed.clear();
        self.battery.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Overview {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Overview {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Position {
    // message fields
    pub lat: f64,
    pub lon: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Position {
    fn default() -> &'a Position {
        <Position as ::protobuf::Message>::default_instance()
    }
}

impl Position {
    pub fn new() -> Position {
        ::std::default::Default::default()
    }

    // double lat = 1;


    pub fn get_lat(&self) -> f64 {
        self.lat
    }
    pub fn clear_lat(&mut self) {
        self.lat = 0.;
    }

    // Param is passed by value, moved
    pub fn set_lat(&mut self, v: f64) {
        self.lat = v;
    }

    // double lon = 2;


    pub fn get_lon(&self) -> f64 {
        self.lon
    }
    pub fn clear_lon(&mut self) {
        self.lon = 0.;
    }

    // Param is passed by value, moved
    pub fn set_lon(&mut self, v: f64) {
        self.lon = v;
    }
}

impl ::protobuf::Message for Position {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.lat = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.lon = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.lat != 0. {
            my_size += 9;
        }
        if self.lon != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.lat != 0. {
            os.write_double(1, self.lat)?;
        }
        if self.lon != 0. {
            os.write_double(2, self.lon)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Position {
        Position::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "lat",
                    |m: &Position| { &m.lat },
                    |m: &mut Position| { &mut m.lat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "lon",
                    |m: &Position| { &m.lon },
                    |m: &mut Position| { &mut m.lon },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Position>(
                    "Position",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Position {
        static mut instance: ::protobuf::lazy::Lazy<Position> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Position,
        };
        unsafe {
            instance.get(Position::new)
        }
    }
}

impl ::protobuf::Clear for Position {
    fn clear(&mut self) {
        self.lat = 0.;
        self.lon = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Position {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Position {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Rotation {
    // message fields
    pub yaw: f64,
    pub pitch: f64,
    pub roll: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Rotation {
    fn default() -> &'a Rotation {
        <Rotation as ::protobuf::Message>::default_instance()
    }
}

impl Rotation {
    pub fn new() -> Rotation {
        ::std::default::Default::default()
    }

    // double yaw = 1;


    pub fn get_yaw(&self) -> f64 {
        self.yaw
    }
    pub fn clear_yaw(&mut self) {
        self.yaw = 0.;
    }

    // Param is passed by value, moved
    pub fn set_yaw(&mut self, v: f64) {
        self.yaw = v;
    }

    // double pitch = 2;


    pub fn get_pitch(&self) -> f64 {
        self.pitch
    }
    pub fn clear_pitch(&mut self) {
        self.pitch = 0.;
    }

    // Param is passed by value, moved
    pub fn set_pitch(&mut self, v: f64) {
        self.pitch = v;
    }

    // double roll = 3;


    pub fn get_roll(&self) -> f64 {
        self.roll
    }
    pub fn clear_roll(&mut self) {
        self.roll = 0.;
    }

    // Param is passed by value, moved
    pub fn set_roll(&mut self, v: f64) {
        self.roll = v;
    }
}

impl ::protobuf::Message for Rotation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.yaw = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.pitch = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.roll = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.yaw != 0. {
            my_size += 9;
        }
        if self.pitch != 0. {
            my_size += 9;
        }
        if self.roll != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.yaw != 0. {
            os.write_double(1, self.yaw)?;
        }
        if self.pitch != 0. {
            os.write_double(2, self.pitch)?;
        }
        if self.roll != 0. {
            os.write_double(3, self.roll)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Rotation {
        Rotation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "yaw",
                    |m: &Rotation| { &m.yaw },
                    |m: &mut Rotation| { &mut m.yaw },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "pitch",
                    |m: &Rotation| { &m.pitch },
                    |m: &mut Rotation| { &mut m.pitch },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "roll",
                    |m: &Rotation| { &m.roll },
                    |m: &mut Rotation| { &mut m.roll },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Rotation>(
                    "Rotation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Rotation {
        static mut instance: ::protobuf::lazy::Lazy<Rotation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Rotation,
        };
        unsafe {
            instance.get(Rotation::new)
        }
    }
}

impl ::protobuf::Clear for Rotation {
    fn clear(&mut self) {
        self.yaw = 0.;
        self.pitch = 0.;
        self.roll = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Rotation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rotation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Altitude {
    // message fields
    pub msl: f64,
    pub agl: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Altitude {
    fn default() -> &'a Altitude {
        <Altitude as ::protobuf::Message>::default_instance()
    }
}

impl Altitude {
    pub fn new() -> Altitude {
        ::std::default::Default::default()
    }

    // double msl = 1;


    pub fn get_msl(&self) -> f64 {
        self.msl
    }
    pub fn clear_msl(&mut self) {
        self.msl = 0.;
    }

    // Param is passed by value, moved
    pub fn set_msl(&mut self, v: f64) {
        self.msl = v;
    }

    // double agl = 2;


    pub fn get_agl(&self) -> f64 {
        self.agl
    }
    pub fn clear_agl(&mut self) {
        self.agl = 0.;
    }

    // Param is passed by value, moved
    pub fn set_agl(&mut self, v: f64) {
        self.agl = v;
    }
}

impl ::protobuf::Message for Altitude {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.msl = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.agl = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.msl != 0. {
            my_size += 9;
        }
        if self.agl != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.msl != 0. {
            os.write_double(1, self.msl)?;
        }
        if self.agl != 0. {
            os.write_double(2, self.agl)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Altitude {
        Altitude::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "msl",
                    |m: &Altitude| { &m.msl },
                    |m: &mut Altitude| { &mut m.msl },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "agl",
                    |m: &Altitude| { &m.agl },
                    |m: &mut Altitude| { &mut m.agl },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Altitude>(
                    "Altitude",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Altitude {
        static mut instance: ::protobuf::lazy::Lazy<Altitude> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Altitude,
        };
        unsafe {
            instance.get(Altitude::new)
        }
    }
}

impl ::protobuf::Clear for Altitude {
    fn clear(&mut self) {
        self.msl = 0.;
        self.agl = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Altitude {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Altitude {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Velocity {
    // message fields
    pub x: f64,
    pub y: f64,
    pub z: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Velocity {
    fn default() -> &'a Velocity {
        <Velocity as ::protobuf::Message>::default_instance()
    }
}

impl Velocity {
    pub fn new() -> Velocity {
        ::std::default::Default::default()
    }

    // double x = 1;


    pub fn get_x(&self) -> f64 {
        self.x
    }
    pub fn clear_x(&mut self) {
        self.x = 0.;
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f64) {
        self.x = v;
    }

    // double y = 2;


    pub fn get_y(&self) -> f64 {
        self.y
    }
    pub fn clear_y(&mut self) {
        self.y = 0.;
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f64) {
        self.y = v;
    }

    // double z = 3;


    pub fn get_z(&self) -> f64 {
        self.z
    }
    pub fn clear_z(&mut self) {
        self.z = 0.;
    }

    // Param is passed by value, moved
    pub fn set_z(&mut self, v: f64) {
        self.z = v;
    }
}

impl ::protobuf::Message for Velocity {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.x = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.y = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.z = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.x != 0. {
            my_size += 9;
        }
        if self.y != 0. {
            my_size += 9;
        }
        if self.z != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.x != 0. {
            os.write_double(1, self.x)?;
        }
        if self.y != 0. {
            os.write_double(2, self.y)?;
        }
        if self.z != 0. {
            os.write_double(3, self.z)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Velocity {
        Velocity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "x",
                    |m: &Velocity| { &m.x },
                    |m: &mut Velocity| { &mut m.x },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "y",
                    |m: &Velocity| { &m.y },
                    |m: &mut Velocity| { &mut m.y },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "z",
                    |m: &Velocity| { &m.z },
                    |m: &mut Velocity| { &mut m.z },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Velocity>(
                    "Velocity",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Velocity {
        static mut instance: ::protobuf::lazy::Lazy<Velocity> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Velocity,
        };
        unsafe {
            instance.get(Velocity::new)
        }
    }
}

impl ::protobuf::Clear for Velocity {
    fn clear(&mut self) {
        self.x = 0.;
        self.y = 0.;
        self.z = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Velocity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Velocity {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Speed {
    // message fields
    pub airspeed: f64,
    pub ground_speed: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Speed {
    fn default() -> &'a Speed {
        <Speed as ::protobuf::Message>::default_instance()
    }
}

impl Speed {
    pub fn new() -> Speed {
        ::std::default::Default::default()
    }

    // double airspeed = 1;


    pub fn get_airspeed(&self) -> f64 {
        self.airspeed
    }
    pub fn clear_airspeed(&mut self) {
        self.airspeed = 0.;
    }

    // Param is passed by value, moved
    pub fn set_airspeed(&mut self, v: f64) {
        self.airspeed = v;
    }

    // double ground_speed = 2;


    pub fn get_ground_speed(&self) -> f64 {
        self.ground_speed
    }
    pub fn clear_ground_speed(&mut self) {
        self.ground_speed = 0.;
    }

    // Param is passed by value, moved
    pub fn set_ground_speed(&mut self, v: f64) {
        self.ground_speed = v;
    }
}

impl ::protobuf::Message for Speed {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.airspeed = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.ground_speed = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.airspeed != 0. {
            my_size += 9;
        }
        if self.ground_speed != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.airspeed != 0. {
            os.write_double(1, self.airspeed)?;
        }
        if self.ground_speed != 0. {
            os.write_double(2, self.ground_speed)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Speed {
        Speed::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "airspeed",
                    |m: &Speed| { &m.airspeed },
                    |m: &mut Speed| { &mut m.airspeed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "ground_speed",
                    |m: &Speed| { &m.ground_speed },
                    |m: &mut Speed| { &mut m.ground_speed },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Speed>(
                    "Speed",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Speed {
        static mut instance: ::protobuf::lazy::Lazy<Speed> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Speed,
        };
        unsafe {
            instance.get(Speed::new)
        }
    }
}

impl ::protobuf::Clear for Speed {
    fn clear(&mut self) {
        self.airspeed = 0.;
        self.ground_speed = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Speed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Speed {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Battery {
    // message fields
    pub voltage: f64,
    pub current: f64,
    pub percentage: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Battery {
    fn default() -> &'a Battery {
        <Battery as ::protobuf::Message>::default_instance()
    }
}

impl Battery {
    pub fn new() -> Battery {
        ::std::default::Default::default()
    }

    // double voltage = 1;


    pub fn get_voltage(&self) -> f64 {
        self.voltage
    }
    pub fn clear_voltage(&mut self) {
        self.voltage = 0.;
    }

    // Param is passed by value, moved
    pub fn set_voltage(&mut self, v: f64) {
        self.voltage = v;
    }

    // double current = 2;


    pub fn get_current(&self) -> f64 {
        self.current
    }
    pub fn clear_current(&mut self) {
        self.current = 0.;
    }

    // Param is passed by value, moved
    pub fn set_current(&mut self, v: f64) {
        self.current = v;
    }

    // int32 percentage = 3;


    pub fn get_percentage(&self) -> i32 {
        self.percentage
    }
    pub fn clear_percentage(&mut self) {
        self.percentage = 0;
    }

    // Param is passed by value, moved
    pub fn set_percentage(&mut self, v: i32) {
        self.percentage = v;
    }
}

impl ::protobuf::Message for Battery {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.voltage = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.current = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.percentage = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.voltage != 0. {
            my_size += 9;
        }
        if self.current != 0. {
            my_size += 9;
        }
        if self.percentage != 0 {
            my_size += ::protobuf::rt::value_size(3, self.percentage, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.voltage != 0. {
            os.write_double(1, self.voltage)?;
        }
        if self.current != 0. {
            os.write_double(2, self.current)?;
        }
        if self.percentage != 0 {
            os.write_int32(3, self.percentage)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Battery {
        Battery::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "voltage",
                    |m: &Battery| { &m.voltage },
                    |m: &mut Battery| { &mut m.voltage },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "current",
                    |m: &Battery| { &m.current },
                    |m: &mut Battery| { &mut m.current },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "percentage",
                    |m: &Battery| { &m.percentage },
                    |m: &mut Battery| { &mut m.percentage },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Battery>(
                    "Battery",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Battery {
        static mut instance: ::protobuf::lazy::Lazy<Battery> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Battery,
        };
        unsafe {
            instance.get(Battery::new)
        }
    }
}

impl ::protobuf::Clear for Battery {
    fn clear(&mut self) {
        self.voltage = 0.;
        self.current = 0.;
        self.percentage = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Battery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Battery {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CameraTelem {
    // message fields
    pub time: f64,
    pub lat: f64,
    pub lon: f64,
    pub alt: f64,
    pub yaw: f64,
    pub pitch: f64,
    pub roll: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CameraTelem {
    fn default() -> &'a CameraTelem {
        <CameraTelem as ::protobuf::Message>::default_instance()
    }
}

impl CameraTelem {
    pub fn new() -> CameraTelem {
        ::std::default::Default::default()
    }

    // double time = 1;


    pub fn get_time(&self) -> f64 {
        self.time
    }
    pub fn clear_time(&mut self) {
        self.time = 0.;
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: f64) {
        self.time = v;
    }

    // double lat = 2;


    pub fn get_lat(&self) -> f64 {
        self.lat
    }
    pub fn clear_lat(&mut self) {
        self.lat = 0.;
    }

    // Param is passed by value, moved
    pub fn set_lat(&mut self, v: f64) {
        self.lat = v;
    }

    // double lon = 3;


    pub fn get_lon(&self) -> f64 {
        self.lon
    }
    pub fn clear_lon(&mut self) {
        self.lon = 0.;
    }

    // Param is passed by value, moved
    pub fn set_lon(&mut self, v: f64) {
        self.lon = v;
    }

    // double alt = 4;


    pub fn get_alt(&self) -> f64 {
        self.alt
    }
    pub fn clear_alt(&mut self) {
        self.alt = 0.;
    }

    // Param is passed by value, moved
    pub fn set_alt(&mut self, v: f64) {
        self.alt = v;
    }

    // double yaw = 5;


    pub fn get_yaw(&self) -> f64 {
        self.yaw
    }
    pub fn clear_yaw(&mut self) {
        self.yaw = 0.;
    }

    // Param is passed by value, moved
    pub fn set_yaw(&mut self, v: f64) {
        self.yaw = v;
    }

    // double pitch = 6;


    pub fn get_pitch(&self) -> f64 {
        self.pitch
    }
    pub fn clear_pitch(&mut self) {
        self.pitch = 0.;
    }

    // Param is passed by value, moved
    pub fn set_pitch(&mut self, v: f64) {
        self.pitch = v;
    }

    // double roll = 7;


    pub fn get_roll(&self) -> f64 {
        self.roll
    }
    pub fn clear_roll(&mut self) {
        self.roll = 0.;
    }

    // Param is passed by value, moved
    pub fn set_roll(&mut self, v: f64) {
        self.roll = v;
    }
}

impl ::protobuf::Message for CameraTelem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.time = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.lat = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.lon = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.alt = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.yaw = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.pitch = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.roll = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.time != 0. {
            my_size += 9;
        }
        if self.lat != 0. {
            my_size += 9;
        }
        if self.lon != 0. {
            my_size += 9;
        }
        if self.alt != 0. {
            my_size += 9;
        }
        if self.yaw != 0. {
            my_size += 9;
        }
        if self.pitch != 0. {
            my_size += 9;
        }
        if self.roll != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.time != 0. {
            os.write_double(1, self.time)?;
        }
        if self.lat != 0. {
            os.write_double(2, self.lat)?;
        }
        if self.lon != 0. {
            os.write_double(3, self.lon)?;
        }
        if self.alt != 0. {
            os.write_double(4, self.alt)?;
        }
        if self.yaw != 0. {
            os.write_double(5, self.yaw)?;
        }
        if self.pitch != 0. {
            os.write_double(6, self.pitch)?;
        }
        if self.roll != 0. {
            os.write_double(7, self.roll)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CameraTelem {
        CameraTelem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "time",
                    |m: &CameraTelem| { &m.time },
                    |m: &mut CameraTelem| { &mut m.time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "lat",
                    |m: &CameraTelem| { &m.lat },
                    |m: &mut CameraTelem| { &mut m.lat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "lon",
                    |m: &CameraTelem| { &m.lon },
                    |m: &mut CameraTelem| { &mut m.lon },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "alt",
                    |m: &CameraTelem| { &m.alt },
                    |m: &mut CameraTelem| { &mut m.alt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "yaw",
                    |m: &CameraTelem| { &m.yaw },
                    |m: &mut CameraTelem| { &mut m.yaw },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "pitch",
                    |m: &CameraTelem| { &m.pitch },
                    |m: &mut CameraTelem| { &mut m.pitch },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "roll",
                    |m: &CameraTelem| { &m.roll },
                    |m: &mut CameraTelem| { &mut m.roll },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CameraTelem>(
                    "CameraTelem",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CameraTelem {
        static mut instance: ::protobuf::lazy::Lazy<CameraTelem> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CameraTelem,
        };
        unsafe {
            instance.get(CameraTelem::new)
        }
    }
}

impl ::protobuf::Clear for CameraTelem {
    fn clear(&mut self) {
        self.time = 0.;
        self.lat = 0.;
        self.lon = 0.;
        self.alt = 0.;
        self.yaw = 0.;
        self.pitch = 0.;
        self.roll = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CameraTelem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CameraTelem {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawMission {
    // message fields
    pub time: f64,
    pub mission_items: ::protobuf::RepeatedField<RawMission_RawMissionItem>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawMission {
    fn default() -> &'a RawMission {
        <RawMission as ::protobuf::Message>::default_instance()
    }
}

impl RawMission {
    pub fn new() -> RawMission {
        ::std::default::Default::default()
    }

    // double time = 1;


    pub fn get_time(&self) -> f64 {
        self.time
    }
    pub fn clear_time(&mut self) {
        self.time = 0.;
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: f64) {
        self.time = v;
    }

    // repeated .telemetry.RawMission.RawMissionItem mission_items = 2;


    pub fn get_mission_items(&self) -> &[RawMission_RawMissionItem] {
        &self.mission_items
    }
    pub fn clear_mission_items(&mut self) {
        self.mission_items.clear();
    }

    // Param is passed by value, moved
    pub fn set_mission_items(&mut self, v: ::protobuf::RepeatedField<RawMission_RawMissionItem>) {
        self.mission_items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mission_items(&mut self) -> &mut ::protobuf::RepeatedField<RawMission_RawMissionItem> {
        &mut self.mission_items
    }

    // Take field
    pub fn take_mission_items(&mut self) -> ::protobuf::RepeatedField<RawMission_RawMissionItem> {
        ::std::mem::replace(&mut self.mission_items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RawMission {
    fn is_initialized(&self) -> bool {
        for v in &self.mission_items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.time = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.mission_items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.time != 0. {
            my_size += 9;
        }
        for value in &self.mission_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.time != 0. {
            os.write_double(1, self.time)?;
        }
        for v in &self.mission_items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawMission {
        RawMission::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "time",
                    |m: &RawMission| { &m.time },
                    |m: &mut RawMission| { &mut m.time },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RawMission_RawMissionItem>>(
                    "mission_items",
                    |m: &RawMission| { &m.mission_items },
                    |m: &mut RawMission| { &mut m.mission_items },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RawMission>(
                    "RawMission",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RawMission {
        static mut instance: ::protobuf::lazy::Lazy<RawMission> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawMission,
        };
        unsafe {
            instance.get(RawMission::new)
        }
    }
}

impl ::protobuf::Clear for RawMission {
    fn clear(&mut self) {
        self.time = 0.;
        self.mission_items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RawMission {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawMission {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawMission_RawMissionItem {
    // message fields
    pub target_system: u32,
    pub target_component: u32,
    pub seq: u32,
    pub frame: u32,
    pub command: u32,
    pub current: u32,
    pub autocontinue: u32,
    pub param_1: f32,
    pub param_2: f32,
    pub param_3: f32,
    pub param_4: f32,
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub mission_type: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawMission_RawMissionItem {
    fn default() -> &'a RawMission_RawMissionItem {
        <RawMission_RawMissionItem as ::protobuf::Message>::default_instance()
    }
}

impl RawMission_RawMissionItem {
    pub fn new() -> RawMission_RawMissionItem {
        ::std::default::Default::default()
    }

    // uint32 target_system = 1;


    pub fn get_target_system(&self) -> u32 {
        self.target_system
    }
    pub fn clear_target_system(&mut self) {
        self.target_system = 0;
    }

    // Param is passed by value, moved
    pub fn set_target_system(&mut self, v: u32) {
        self.target_system = v;
    }

    // uint32 target_component = 2;


    pub fn get_target_component(&self) -> u32 {
        self.target_component
    }
    pub fn clear_target_component(&mut self) {
        self.target_component = 0;
    }

    // Param is passed by value, moved
    pub fn set_target_component(&mut self, v: u32) {
        self.target_component = v;
    }

    // uint32 seq = 3;


    pub fn get_seq(&self) -> u32 {
        self.seq
    }
    pub fn clear_seq(&mut self) {
        self.seq = 0;
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: u32) {
        self.seq = v;
    }

    // uint32 frame = 4;


    pub fn get_frame(&self) -> u32 {
        self.frame
    }
    pub fn clear_frame(&mut self) {
        self.frame = 0;
    }

    // Param is passed by value, moved
    pub fn set_frame(&mut self, v: u32) {
        self.frame = v;
    }

    // uint32 command = 5;


    pub fn get_command(&self) -> u32 {
        self.command
    }
    pub fn clear_command(&mut self) {
        self.command = 0;
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: u32) {
        self.command = v;
    }

    // uint32 current = 6;


    pub fn get_current(&self) -> u32 {
        self.current
    }
    pub fn clear_current(&mut self) {
        self.current = 0;
    }

    // Param is passed by value, moved
    pub fn set_current(&mut self, v: u32) {
        self.current = v;
    }

    // uint32 autocontinue = 7;


    pub fn get_autocontinue(&self) -> u32 {
        self.autocontinue
    }
    pub fn clear_autocontinue(&mut self) {
        self.autocontinue = 0;
    }

    // Param is passed by value, moved
    pub fn set_autocontinue(&mut self, v: u32) {
        self.autocontinue = v;
    }

    // float param_1 = 8;


    pub fn get_param_1(&self) -> f32 {
        self.param_1
    }
    pub fn clear_param_1(&mut self) {
        self.param_1 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_param_1(&mut self, v: f32) {
        self.param_1 = v;
    }

    // float param_2 = 9;


    pub fn get_param_2(&self) -> f32 {
        self.param_2
    }
    pub fn clear_param_2(&mut self) {
        self.param_2 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_param_2(&mut self, v: f32) {
        self.param_2 = v;
    }

    // float param_3 = 10;


    pub fn get_param_3(&self) -> f32 {
        self.param_3
    }
    pub fn clear_param_3(&mut self) {
        self.param_3 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_param_3(&mut self, v: f32) {
        self.param_3 = v;
    }

    // float param_4 = 11;


    pub fn get_param_4(&self) -> f32 {
        self.param_4
    }
    pub fn clear_param_4(&mut self) {
        self.param_4 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_param_4(&mut self, v: f32) {
        self.param_4 = v;
    }

    // float x = 12;


    pub fn get_x(&self) -> f32 {
        self.x
    }
    pub fn clear_x(&mut self) {
        self.x = 0.;
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = v;
    }

    // float y = 13;


    pub fn get_y(&self) -> f32 {
        self.y
    }
    pub fn clear_y(&mut self) {
        self.y = 0.;
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = v;
    }

    // float z = 14;


    pub fn get_z(&self) -> f32 {
        self.z
    }
    pub fn clear_z(&mut self) {
        self.z = 0.;
    }

    // Param is passed by value, moved
    pub fn set_z(&mut self, v: f32) {
        self.z = v;
    }

    // uint32 mission_type = 15;


    pub fn get_mission_type(&self) -> u32 {
        self.mission_type
    }
    pub fn clear_mission_type(&mut self) {
        self.mission_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_mission_type(&mut self, v: u32) {
        self.mission_type = v;
    }
}

impl ::protobuf::Message for RawMission_RawMissionItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.target_system = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.target_component = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.frame = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.command = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.current = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.autocontinue = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.param_1 = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.param_2 = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.param_3 = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.param_4 = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.x = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.y = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.z = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mission_type = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.target_system != 0 {
            my_size += ::protobuf::rt::value_size(1, self.target_system, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.target_component != 0 {
            my_size += ::protobuf::rt::value_size(2, self.target_component, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.seq != 0 {
            my_size += ::protobuf::rt::value_size(3, self.seq, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.frame != 0 {
            my_size += ::protobuf::rt::value_size(4, self.frame, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.command != 0 {
            my_size += ::protobuf::rt::value_size(5, self.command, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.current != 0 {
            my_size += ::protobuf::rt::value_size(6, self.current, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.autocontinue != 0 {
            my_size += ::protobuf::rt::value_size(7, self.autocontinue, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.param_1 != 0. {
            my_size += 5;
        }
        if self.param_2 != 0. {
            my_size += 5;
        }
        if self.param_3 != 0. {
            my_size += 5;
        }
        if self.param_4 != 0. {
            my_size += 5;
        }
        if self.x != 0. {
            my_size += 5;
        }
        if self.y != 0. {
            my_size += 5;
        }
        if self.z != 0. {
            my_size += 5;
        }
        if self.mission_type != 0 {
            my_size += ::protobuf::rt::value_size(15, self.mission_type, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.target_system != 0 {
            os.write_uint32(1, self.target_system)?;
        }
        if self.target_component != 0 {
            os.write_uint32(2, self.target_component)?;
        }
        if self.seq != 0 {
            os.write_uint32(3, self.seq)?;
        }
        if self.frame != 0 {
            os.write_uint32(4, self.frame)?;
        }
        if self.command != 0 {
            os.write_uint32(5, self.command)?;
        }
        if self.current != 0 {
            os.write_uint32(6, self.current)?;
        }
        if self.autocontinue != 0 {
            os.write_uint32(7, self.autocontinue)?;
        }
        if self.param_1 != 0. {
            os.write_float(8, self.param_1)?;
        }
        if self.param_2 != 0. {
            os.write_float(9, self.param_2)?;
        }
        if self.param_3 != 0. {
            os.write_float(10, self.param_3)?;
        }
        if self.param_4 != 0. {
            os.write_float(11, self.param_4)?;
        }
        if self.x != 0. {
            os.write_float(12, self.x)?;
        }
        if self.y != 0. {
            os.write_float(13, self.y)?;
        }
        if self.z != 0. {
            os.write_float(14, self.z)?;
        }
        if self.mission_type != 0 {
            os.write_uint32(15, self.mission_type)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawMission_RawMissionItem {
        RawMission_RawMissionItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "target_system",
                    |m: &RawMission_RawMissionItem| { &m.target_system },
                    |m: &mut RawMission_RawMissionItem| { &mut m.target_system },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "target_component",
                    |m: &RawMission_RawMissionItem| { &m.target_component },
                    |m: &mut RawMission_RawMissionItem| { &mut m.target_component },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "seq",
                    |m: &RawMission_RawMissionItem| { &m.seq },
                    |m: &mut RawMission_RawMissionItem| { &mut m.seq },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "frame",
                    |m: &RawMission_RawMissionItem| { &m.frame },
                    |m: &mut RawMission_RawMissionItem| { &mut m.frame },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "command",
                    |m: &RawMission_RawMissionItem| { &m.command },
                    |m: &mut RawMission_RawMissionItem| { &mut m.command },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "current",
                    |m: &RawMission_RawMissionItem| { &m.current },
                    |m: &mut RawMission_RawMissionItem| { &mut m.current },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "autocontinue",
                    |m: &RawMission_RawMissionItem| { &m.autocontinue },
                    |m: &mut RawMission_RawMissionItem| { &mut m.autocontinue },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "param_1",
                    |m: &RawMission_RawMissionItem| { &m.param_1 },
                    |m: &mut RawMission_RawMissionItem| { &mut m.param_1 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "param_2",
                    |m: &RawMission_RawMissionItem| { &m.param_2 },
                    |m: &mut RawMission_RawMissionItem| { &mut m.param_2 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "param_3",
                    |m: &RawMission_RawMissionItem| { &m.param_3 },
                    |m: &mut RawMission_RawMissionItem| { &mut m.param_3 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "param_4",
                    |m: &RawMission_RawMissionItem| { &m.param_4 },
                    |m: &mut RawMission_RawMissionItem| { &mut m.param_4 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "x",
                    |m: &RawMission_RawMissionItem| { &m.x },
                    |m: &mut RawMission_RawMissionItem| { &mut m.x },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "y",
                    |m: &RawMission_RawMissionItem| { &m.y },
                    |m: &mut RawMission_RawMissionItem| { &mut m.y },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "z",
                    |m: &RawMission_RawMissionItem| { &m.z },
                    |m: &mut RawMission_RawMissionItem| { &mut m.z },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mission_type",
                    |m: &RawMission_RawMissionItem| { &m.mission_type },
                    |m: &mut RawMission_RawMissionItem| { &mut m.mission_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RawMission_RawMissionItem>(
                    "RawMission_RawMissionItem",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RawMission_RawMissionItem {
        static mut instance: ::protobuf::lazy::Lazy<RawMission_RawMissionItem> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawMission_RawMissionItem,
        };
        unsafe {
            instance.get(RawMission_RawMissionItem::new)
        }
    }
}

impl ::protobuf::Clear for RawMission_RawMissionItem {
    fn clear(&mut self) {
        self.target_system = 0;
        self.target_component = 0;
        self.seq = 0;
        self.frame = 0;
        self.command = 0;
        self.current = 0;
        self.autocontinue = 0;
        self.param_1 = 0.;
        self.param_2 = 0.;
        self.param_3 = 0.;
        self.param_4 = 0.;
        self.x = 0.;
        self.y = 0.;
        self.z = 0.;
        self.mission_type = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RawMission_RawMissionItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawMission_RawMissionItem {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MissionCurrent {
    // message fields
    pub time: f64,
    pub item_number: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MissionCurrent {
    fn default() -> &'a MissionCurrent {
        <MissionCurrent as ::protobuf::Message>::default_instance()
    }
}

impl MissionCurrent {
    pub fn new() -> MissionCurrent {
        ::std::default::Default::default()
    }

    // double time = 1;


    pub fn get_time(&self) -> f64 {
        self.time
    }
    pub fn clear_time(&mut self) {
        self.time = 0.;
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: f64) {
        self.time = v;
    }

    // uint32 item_number = 2;


    pub fn get_item_number(&self) -> u32 {
        self.item_number
    }
    pub fn clear_item_number(&mut self) {
        self.item_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_item_number(&mut self, v: u32) {
        self.item_number = v;
    }
}

impl ::protobuf::Message for MissionCurrent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.time = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_number = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.time != 0. {
            my_size += 9;
        }
        if self.item_number != 0 {
            my_size += ::protobuf::rt::value_size(2, self.item_number, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.time != 0. {
            os.write_double(1, self.time)?;
        }
        if self.item_number != 0 {
            os.write_uint32(2, self.item_number)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MissionCurrent {
        MissionCurrent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "time",
                    |m: &MissionCurrent| { &m.time },
                    |m: &mut MissionCurrent| { &mut m.time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_number",
                    |m: &MissionCurrent| { &m.item_number },
                    |m: &mut MissionCurrent| { &mut m.item_number },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MissionCurrent>(
                    "MissionCurrent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MissionCurrent {
        static mut instance: ::protobuf::lazy::Lazy<MissionCurrent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MissionCurrent,
        };
        unsafe {
            instance.get(MissionCurrent::new)
        }
    }
}

impl ::protobuf::Clear for MissionCurrent {
    fn clear(&mut self) {
        self.time = 0.;
        self.item_number = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MissionCurrent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MissionCurrent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0ftelemetry.proto\x12\ttelemetry\"\x90\x02\n\x08Overview\x12\x12\n\
    \x04time\x18\x01\x20\x01(\x01R\x04time\x12%\n\x03pos\x18\x02\x20\x01(\
    \x0b2\x13.telemetry.PositionR\x03pos\x12%\n\x03rot\x18\x03\x20\x01(\x0b2\
    \x13.telemetry.RotationR\x03rot\x12%\n\x03alt\x18\x04\x20\x01(\x0b2\x13.\
    telemetry.AltitudeR\x03alt\x12%\n\x03vel\x18\x05\x20\x01(\x0b2\x13.telem\
    etry.VelocityR\x03vel\x12&\n\x05speed\x18\x06\x20\x01(\x0b2\x10.telemetr\
    y.SpeedR\x05speed\x12,\n\x07battery\x18\x07\x20\x01(\x0b2\x12.telemetry.\
    BatteryR\x07battery\".\n\x08Position\x12\x10\n\x03lat\x18\x01\x20\x01(\
    \x01R\x03lat\x12\x10\n\x03lon\x18\x02\x20\x01(\x01R\x03lon\"F\n\x08Rotat\
    ion\x12\x10\n\x03yaw\x18\x01\x20\x01(\x01R\x03yaw\x12\x14\n\x05pitch\x18\
    \x02\x20\x01(\x01R\x05pitch\x12\x12\n\x04roll\x18\x03\x20\x01(\x01R\x04r\
    oll\".\n\x08Altitude\x12\x10\n\x03msl\x18\x01\x20\x01(\x01R\x03msl\x12\
    \x10\n\x03agl\x18\x02\x20\x01(\x01R\x03agl\"4\n\x08Velocity\x12\x0c\n\
    \x01x\x18\x01\x20\x01(\x01R\x01x\x12\x0c\n\x01y\x18\x02\x20\x01(\x01R\
    \x01y\x12\x0c\n\x01z\x18\x03\x20\x01(\x01R\x01z\"F\n\x05Speed\x12\x1a\n\
    \x08airspeed\x18\x01\x20\x01(\x01R\x08airspeed\x12!\n\x0cground_speed\
    \x18\x02\x20\x01(\x01R\x0bgroundSpeed\"]\n\x07Battery\x12\x18\n\x07volta\
    ge\x18\x01\x20\x01(\x01R\x07voltage\x12\x18\n\x07current\x18\x02\x20\x01\
    (\x01R\x07current\x12\x1e\n\npercentage\x18\x03\x20\x01(\x05R\npercentag\
    e\"\x93\x01\n\x0bCameraTelem\x12\x12\n\x04time\x18\x01\x20\x01(\x01R\x04\
    time\x12\x10\n\x03lat\x18\x02\x20\x01(\x01R\x03lat\x12\x10\n\x03lon\x18\
    \x03\x20\x01(\x01R\x03lon\x12\x10\n\x03alt\x18\x04\x20\x01(\x01R\x03alt\
    \x12\x10\n\x03yaw\x18\x05\x20\x01(\x01R\x03yaw\x12\x14\n\x05pitch\x18\
    \x06\x20\x01(\x01R\x05pitch\x12\x12\n\x04roll\x18\x07\x20\x01(\x01R\x04r\
    oll\"\xff\x03\n\nRawMission\x12\x12\n\x04time\x18\x01\x20\x01(\x01R\x04t\
    ime\x12I\n\rmission_items\x18\x02\x20\x03(\x0b2$.telemetry.RawMission.Ra\
    wMissionItemR\x0cmissionItems\x1a\x91\x03\n\x0eRawMissionItem\x12#\n\rta\
    rget_system\x18\x01\x20\x01(\rR\x0ctargetSystem\x12)\n\x10target_compone\
    nt\x18\x02\x20\x01(\rR\x0ftargetComponent\x12\x10\n\x03seq\x18\x03\x20\
    \x01(\rR\x03seq\x12\x14\n\x05frame\x18\x04\x20\x01(\rR\x05frame\x12\x18\
    \n\x07command\x18\x05\x20\x01(\rR\x07command\x12\x18\n\x07current\x18\
    \x06\x20\x01(\rR\x07current\x12\"\n\x0cautocontinue\x18\x07\x20\x01(\rR\
    \x0cautocontinue\x12\x17\n\x07param_1\x18\x08\x20\x01(\x02R\x06param1\
    \x12\x17\n\x07param_2\x18\t\x20\x01(\x02R\x06param2\x12\x17\n\x07param_3\
    \x18\n\x20\x01(\x02R\x06param3\x12\x17\n\x07param_4\x18\x0b\x20\x01(\x02\
    R\x06param4\x12\x0c\n\x01x\x18\x0c\x20\x01(\x02R\x01x\x12\x0c\n\x01y\x18\
    \r\x20\x01(\x02R\x01y\x12\x0c\n\x01z\x18\x0e\x20\x01(\x02R\x01z\x12!\n\
    \x0cmission_type\x18\x0f\x20\x01(\rR\x0bmissionType\"E\n\x0eMissionCurre\
    nt\x12\x12\n\x04time\x18\x01\x20\x01(\x01R\x04time\x12\x1f\n\x0bitem_num\
    ber\x18\x02\x20\x01(\rR\nitemNumberb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
